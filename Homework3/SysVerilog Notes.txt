SystemVerilog (4 parts)

  1. Logistics (compiler options, enable coverage)
  2. Build Covergroups, Build Coverpoints
  3. Constraint Randomization
  4. Interface 2 & 3 with your module (Check report)
  
  
  
  
//-----Constraint Randomization-----//
class random_buy;
  rand int index;
  constraint c { index > 0; index <=4; }      //0-4 for 4 coins and a no coin signal
  // Want to create buy variable and constraint, but make sure you don't buy every cycle in order to meet requirements.
  // Therefore, have buy be something like [0, 0, 0, 1, 1]
  // Also want to create a random variable for buying a product [00, 01, 10, 11]
endclass



module testBench()
  reg ....
  wire ....
  VendingMachine VM (clk, reset ....)
  
//-----Building Covergroups and Coverpoints-----//
  covergroup Trans_Cov @ (clk)
    PENNY: coverpoint VM.penny {bins pennyDetected = {1};}
    NICKEL: .....
    .
    .
    .
    .
    .
    CREDITS: coverpoint VM.credits {        //1-4, 5-9, 10-24,25-39,40-49,50-74,75-max,max
      bins 1to4 = { [1:4] };
      bins 5to9 = { [5:9] };
      .
      .
      .
    }
  endgroup
  
  covergroup Cross_Cov @ (clk)
    PRODUCTS: coverpoint VM.product {
      .
      .
      .
    }
    ERROR: coverpoint VM.error {
      .
      .
      .
    }
    CROSS_COV: cross PRODUCTS, ERROR;
  endgroup


  initial begin
  
    //---Instantiate classes and covergoups---//
    random_buy rb = new();
    ...
    Trans_Cov tc = new();
    Cross_Cov cc = new();
    ...
    
    // Set initial values
    
    
    //---Randomize Inputs---//
    repeat (100) begin
      assert (rb.randomize())       //rb.index (and any other rand var in rb) now has random value w/in constraints
     
      // push coins (5 cycles)                  //Parallel
      // buy item / don't buy item / product    //Parallel
      /*
      *   The idea for this is that rb.index will go to an index in an array of sorts. The array will hold the serialIn values
      *   for penny, nickel, dime, quarter, and no input.
      *   Then a number for the corresponding coin code is pushed in each clock cycle, simulating the serialIn of a coin.
      *   Make sure to pad penny with 1's at the end to prevent possibility of confusion.
      *
      *   d   [penny, nickel, dime, quarter, no coin]
      *   d[3] = 00110
      *
      *   buy   [0, 0, 0, 1, 1]
      *   product [00, 01, 10, 11]
      */
      
      
      
  end



endmodule
